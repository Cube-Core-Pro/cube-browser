use crate::services::exploit_shell::ExploitShell;
use crate::services::vulnerability_scanner::Vulnerability;
use tauri::State;

/// Get available exploits for vulnerability
#[tauri::command]
pub async fn get_exploits_for_vulnerability(
    vulnerability: serde_json::Value,
    exploit_shell: State<'_, ExploitShell>,
) -> Result<Vec<serde_json::Value>, String> {
    let vuln: Vulnerability = serde_json::from_value(vulnerability).map_err(|e| e.to_string())?;

    Ok(exploit_shell
        .get_exploits_for_vulnerability(&vuln)
        .into_iter()
        .map(|e| serde_json::to_value(e).unwrap())
        .collect())
}

/// Auto-exploit vulnerability with AI
#[tauri::command]
pub async fn auto_exploit_vulnerability(
    vulnerability: serde_json::Value,
    exploit_shell: State<'_, ExploitShell>,
) -> Result<serde_json::Value, String> {
    let vuln: Vulnerability = serde_json::from_value(vulnerability).map_err(|e| e.to_string())?;

    exploit_shell
        .auto_exploit(vuln)
        .await
        .map(|result| serde_json::to_value(result).unwrap())
        .map_err(|e| e.to_string())
}

/// Get exploit history
#[tauri::command]
pub async fn get_exploit_history(
    exploit_shell: State<'_, ExploitShell>,
) -> Result<Vec<serde_json::Value>, String> {
    Ok(exploit_shell
        .get_exploit_history()
        .into_iter()
        .map(|e| serde_json::to_value(e).unwrap())
        .collect())
}

/// Get AI exploit commands
#[tauri::command]
pub async fn get_ai_exploit_commands(
    exploit_shell: State<'_, ExploitShell>,
) -> Result<Vec<serde_json::Value>, String> {
    Ok(exploit_shell
        .get_ai_commands()
        .into_iter()
        .map(|c| serde_json::to_value(c).unwrap())
        .collect())
}

/// Execute AI exploit command
#[tauri::command]
pub async fn execute_exploit_command(
    command: String,
    exploit_shell: State<'_, ExploitShell>,
) -> Result<String, String> {
    exploit_shell
        .execute_command(&command)
        .await
        .map_err(|e| e.to_string())
}
