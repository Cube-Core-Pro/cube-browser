/**
 * Exploit Shell Service
 * 
 * ⚠️ EXTREME DANGER: FOR AUTHORIZED PENETRATION TESTING ONLY
 * Exploit execution and post-exploitation framework.
 * 
 * @module exploitShellService
 */

import { invoke } from '@tauri-apps/api/core';

// ============================================================================
// TYPES
// ============================================================================

export interface ExploitInfo {
  id: string;
  name: string;
  description: string;
  targetType: string;
  severity: 'critical' | 'high' | 'medium';
  cve?: string;
  platforms: string[];
  requirements: string[];
}

export interface ExploitResult {
  success: boolean;
  output: string;
  shellAccess: boolean;
  sessionId?: string;
  error?: string;
  executedAt: number;
}

export interface ExploitHistory {
  id: string;
  exploitId: string;
  target: string;
  result: ExploitResult;
  timestamp: number;
}

export interface AIExploitCommand {
  command: string;
  description: string;
  risk: 'low' | 'medium' | 'high';
  purpose: string;
}

// ============================================================================
// API
// ============================================================================

/**
 * Get available exploits for vulnerability
 */
export async function getExploitsForVulnerability(cve: string): Promise<ExploitInfo[]> {
  try {
    return await invoke<ExploitInfo[]>('get_exploits_for_vulnerability', { cve });
  } catch (error) {
    throw new Error(`Failed to get exploits: ${error}`);
  }
}

/**
 * Auto-exploit vulnerability
 * 
 * ⚠️ DANGER: Automated exploitation - use with extreme caution
 */
export async function autoExploit(
  target: string,
  exploitId: string,
  options?: Record<string, unknown>
): Promise<ExploitResult> {
  try {
    return await invoke<ExploitResult>('auto_exploit_vulnerability', {
      target,
      exploitId,
      options,
    });
  } catch (error) {
    throw new Error(`Failed to auto-exploit: ${error}`);
  }
}

/**
 * Get exploit execution history
 */
export async function getHistory(): Promise<ExploitHistory[]> {
  try {
    return await invoke<ExploitHistory[]>('get_exploit_history');
  } catch (error) {
    throw new Error(`Failed to get exploit history: ${error}`);
  }
}

/**
 * Get AI-powered exploit commands
 */
export async function getAICommands(
  context: string,
  objective: string
): Promise<AIExploitCommand[]> {
  try {
    return await invoke<AIExploitCommand[]>('get_ai_exploit_commands', { context, objective });
  } catch (error) {
    throw new Error(`Failed to get AI commands: ${error}`);
  }
}

/**
 * Execute exploit command in session
 * 
 * ⚠️ DANGER: Direct command execution
 */
export async function executeCommand(sessionId: string, command: string): Promise<string> {
  try {
    return await invoke<string>('execute_exploit_command', { sessionId, command });
  } catch (error) {
    throw new Error(`Failed to execute command: ${error}`);
  }
}

// ============================================================================
// HELPERS
// ============================================================================

export async function getSuccessfulExploits(): Promise<ExploitHistory[]> {
  const history = await getHistory();
  return history.filter(h => h.result.success);
}

export async function getFailedExploits(): Promise<ExploitHistory[]> {
  const history = await getHistory();
  return history.filter(h => !h.result.success);
}

export async function getExploitsByCVE(cve: string): Promise<ExploitHistory[]> {
  const history = await getHistory();
  const exploits = await getExploitsForVulnerability(cve);
  const exploitIds = new Set(exploits.map(e => e.id));
  return history.filter(h => exploitIds.has(h.exploitId));
}

/**
 * Default export
 */
export const exploitShellService = {
  getExploitsForVulnerability,
  autoExploit,
  getHistory,
  getAICommands,
  executeCommand,
  getSuccessfulExploits,
  getFailedExploits,
  getExploitsByCVE,
};

export default exploitShellService;
